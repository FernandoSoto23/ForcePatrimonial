"use client";

import React, { useState } from "react";
import * as XLSX from "xlsx";
import {
  BASE_GEOFENCES_L,
  BASE_GEOFENCES_A,
  BASE_GEOFENCES_T,
  GEOFENCES_L,
  GEOFENCES_A,
  GEOFENCES_T,
  PREDEFINED_GROUPS,
  BASE_GEOFENCES
} from "./geocercas";
/* ======================= CONFIG ======================= */
const GEOCERCAS_PERMITIDAS = new Set<string>([
  ...BASE_GEOFENCES,
  ...BASE_GEOFENCES.map((n) => `${n} ext`),
  ...BASE_GEOFENCES.map((n) => `${n} ext.`),
]);
const API = "https://wialon-geocercas-api.georcercaswialon.workers.dev";
const MAX_AGE_MIN = 15;
const MAX_AGE_SEC = MAX_AGE_MIN * 60;
const CHUNK_SIZE = 150;

/* ======================= UTILS ======================= */

function chunkArray<T>(arr: T[], size: number): T[][] {
  const out: T[][] = [];
  for (let i = 0; i < arr.length; i += size) out.push(arr.slice(i, i + size));
  return out;
}

const fmtDT = (unix?: number) =>
  !unix
    ? "—"
    : new Date(unix * 1000)
      .toISOString()
      .slice(0, 16)
      .replace("T", " ");

function formatHoraActual(): string {
  return new Date().toLocaleTimeString("es-MX", {
    hour12: false,
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
  });
}

/* ======================= GEOFENCES ======================= */



/* ======================= TYPES ======================= */

type Unit = {
  id: number;
  name: string;
  lat?: number;
  lon?: number;
  t?: number;
  speed?: number;
};

type Geofence = {
  id: number;
  name: string;
  categoria?: string | null;
};

type UnitRow = {
  id: number;
  name: string;
  lat?: number;
  lon?: number;
  t?: number;
  speed?: number;
  zones: Geofence[];
  ruta: string;
  segmento: string;
  tipoManual?: string;
  horaTipo?: string;
};

type SearchResult = {
  id: number;
  label: string;
  createdAt: string;
  rows: UnitRow[];
};

/* ======================= LOGIC (NO TOCAR) ======================= */
function getTipoTooltip(row: UnitRow): string {
  const tipo = getTipo(row);

  const nombresSucursal = row.zones
    .filter((z) => isSucursalGeofence(z.name))
    .map((z) => z.name);

  const nombresL = row.zones
    .filter((z) => isLogisticaGeofence(z.name))
    .map((z) => z.name);

  const nombresA = row.zones
    .filter((z) => isAgenciaGeofence(z.name))
    .map((z) => z.name);

  const nombresT = row.zones
    .filter((z) => isTallerGeofence(z.name))
    .map((z) => z.name);

  switch (tipo) {
    case "S":
      return nombresSucursal.length
        ? `Sucursal: ${nombresSucursal.join(", ")}`
        : "Sucursal";
    case "L":
      return nombresL.length
        ? `Logística: ${nombresL.join(", ")}`
        : "Logística";
    case "A":
      return nombresA.length
        ? `Agencia: ${nombresA.join(", ")}`
        : "Agencia";
    case "T":
      return nombresT.length
        ? `Taller: ${nombresT.join(", ")}`
        : "Taller";
    case "I":
      return "Inactivo fuera de geocerca (vel < 10 km/h)";
    default:
      return "Tipo editable (S / L / A / T / I)";
  }
}

function hasSignal(row: UnitRow): boolean {
  if (!row.t) return false;
  const nowSec = Date.now() / 1000;
  return nowSec - row.t <= MAX_AGE_SEC;
}

function isSucursalGeofence(name: string): boolean {
  const raw = name.trim();
  const clean = raw.replace(/\.$/, "");
  return (
    GEOCERCAS_PERMITIDAS.has(clean) ||
    GEOCERCAS_PERMITIDAS.has(`${clean} ext`) ||
    GEOCERCAS_PERMITIDAS.has(clean.replace(/ ext\.?$/, "")) ||
    GEOCERCAS_PERMITIDAS.has(raw)
  );
}

function isLogisticaGeofence(name: string): boolean {
  return GEOFENCES_L.has(name.trim());
}
function isAgenciaGeofence(name: string): boolean {
  return GEOFENCES_A.has(name.trim());
}
function isTallerGeofence(name: string): boolean {
  return GEOFENCES_T.has(name.trim());
}

function getAutoFlag(row: UnitRow): string {
  if (!hasSignal(row)) return "";

  const hasSucursal = row.zones.some((z) => isSucursalGeofence(z.name));
  const hasLogistica = row.zones.some((z) => isLogisticaGeofence(z.name));
  const hasAgencia = row.zones.some((z) => isAgenciaGeofence(z.name));
  const hasTaller = row.zones.some((z) => isTallerGeofence(z.name));

  if (hasSucursal) return "S";
  if (hasLogistica) return "L";
  if (hasAgencia) return "A";
  if (hasTaller) return "T";

  const spd = row.speed ?? 0;
  return spd < 10 ? "I" : "";
}

function getTipo(row: UnitRow): string {
  return (row.tipoManual ?? getAutoFlag(row)).toUpperCase();
}

/* ======================= FETCH (NO TOCAR) ======================= */

async function fetchData(unitNames: string[]) {
  const unitsResp = await fetch(`${API}/wialon/units`);
  const unitsJson = await unitsResp.json();
  const units: Unit[] = unitsJson.units || [];

  const geofResp = await fetch(
    `${API}/wialon/resources/18891825/geofences`
  );
  const geofJson = await geofResp.json();
  const allGeofences: any[] = geofJson.geofences || [];

  const allowedZoneIds: number[] = allGeofences
    .filter((g) => {
      const name = String(g.name || g.n || "");
      return (
        isSucursalGeofence(name) ||
        isLogisticaGeofence(name) ||
        isAgenciaGeofence(name) ||
        isTallerGeofence(name)
      );
    })
    .map((g) => Number(g.id));

  const chunks = chunkArray(unitNames, CHUNK_SIZE);
  const mergedCross: Record<string, any> = {};

  for (const chunk of chunks) {
    const url =
      `${API}/wialon/units/in-geofences/local` +
      `?resource_id=18891825` +
      `&names=${encodeURIComponent(chunk.join(","))}` +
      `&zone_ids=${encodeURIComponent(allowedZoneIds.join(","))}`;

    const resp = await fetch(url);
    const json = await resp.json();
    Object.assign(mergedCross, json.result || {});
  }

  return { units, allGeofences, cross: mergedCross };
}

/* ======================= UI ======================= */

function Badge({ label }: { label: string }) {
  return (
    <span className="inline-flex rounded-full bg-blue-600 px-2 py-0.5 text-xs text-white">
      {label}
    </span>
  );
}

/* ======================= COMPONENT ======================= */

export default function PageUnidadesGeocercas() {
  const [unitInput, setUnitInput] = useState("");
  const [searches, setSearches] = useState<SearchResult[]>([]);
  const [activeSearchId, setActiveSearchId] = useState<number | null>(null);
  const [loading, setLoading] = useState(false);

  const activeSearch =
    searches.find((s) => s.id === activeSearchId) || null;

  const handleSearch = async () => {
    const unitNames = unitInput
      .split(/[\n,]+/)
      .map((s) => s.trim())
      .filter(Boolean);

    if (!unitNames.length) return;

    setLoading(true);

    const { units, allGeofences, cross } = await fetchData(unitNames);

    const unitByName = new Map<string, Unit>();
    units.forEach((u) => unitByName.set(u.name.toLowerCase(), u));

    const geofenceById = new Map<number, Geofence>();
    allGeofences.forEach((g: any) =>
      geofenceById.set(g.id, { id: g.id, name: g.name })
    );

    const zonesByUnitId: Record<number, number[]> = {};
    Object.values(cross).forEach((byUnit: any) => {
      Object.entries(byUnit || {}).forEach(([uid, val]: any) => {
        zonesByUnitId[+uid] = (zonesByUnitId[+uid] || []).concat(val || []);
      });
    });

    const nowSec = Date.now() / 1000;

    const rows: UnitRow[] = unitNames.map((name, idx) => {
      const found = unitByName.get(name.toLowerCase());
      if (!found)
        return { id: 100000 + idx, name, zones: [], ruta: "", segmento: "" };

      const isStale = !found.t || nowSec - found.t > MAX_AGE_SEC;

      const zones = (zonesByUnitId[found.id] || [])
        .map((id) => geofenceById.get(id))
        .filter(Boolean)
        .filter(
          (g) =>
            isSucursalGeofence(g!.name) ||
            isLogisticaGeofence(g!.name) ||
            isAgenciaGeofence(g!.name) ||
            isTallerGeofence(g!.name)
        ) as Geofence[];

      const base: UnitRow = {
        id: found.id,
        name: found.name,
        lat: found.lat,
        lon: found.lon,
        t: found.t,
        speed: found.speed,
        zones: isStale ? [] : zones,
        ruta: "",
        segmento: "",
      };

      const tipo = isStale ? "" : getTipo(base);

      return {
        ...base,
        tipoManual: tipo || undefined,
        horaTipo: tipo ? formatHoraActual() : undefined,
      };
    });

    const search: SearchResult = {
      id: Date.now(),
      label: `Búsqueda ${searches.length + 1}`,
      createdAt: new Date().toISOString().slice(0, 16).replace("T", " "),
      rows,
    };

    setSearches((p) => [...p, search]);
    setActiveSearchId(search.id);
    setLoading(false);
  };

  const updateRow = (id: number, field: keyof UnitRow, val: any) => {
    setSearches((prev) =>
      prev.map((s) =>
        s.id !== activeSearchId
          ? s
          : {
            ...s,
            rows: s.rows.map((r) =>
              r.id === id ? { ...r, [field]: val } : r
            ),
          }
      )
    );
  };
  const handleCopyTipo = async () => {
    if (!searches.length) return;

    // Copiamos SOLO la columna Tipo de la PRIMERA búsqueda
    const txt = searches[0].rows
      .map((r) => getTipo(r))
      .join("\n");

    try {
      await navigator.clipboard.writeText(txt);
      alert("Columna 'Tipo' copiada. Pega directo en Excel ✅");
    } catch (e) {
      console.error("No se pudo copiar:", e);
      alert("No se pudo copiar automáticamente");
    }
  };
  const handleDownloadExcel = () => {
    if (!searches.length) return;

    // ================= HEADER =================
    const header: string[] = [
      "Unidad",
      "Ruta",
      "Segmento",
    ];

    searches.forEach((s, idx) => {
      header.push(`Tipo ${s.label}`);
      header.push(`Hora ${s.label}`);

      if (idx === 0) {
        header.push("Última posición");
        header.push("Lat / Lon");
        header.push("Geocercas");
      }
    });

    // ================= ROWS =================
    const data: any[][] = [];
    data.push(header);

    const baseRows = searches[0].rows;

    baseRows.forEach((_, rowIdx) => {
      const row: any[] = [];

      // Fijas
      row.push(searches[0].rows[rowIdx].name);
      row.push(searches[0].rows[rowIdx].ruta || "");
      row.push(searches[0].rows[rowIdx].segmento || "");

      // Por búsqueda
      searches.forEach((s, searchIdx) => {
        const u = s.rows[rowIdx];

        row.push(getTipo(u));
        row.push(u.horaTipo ?? "");

        if (searchIdx === 0) {
          row.push(fmtDT(u.t));
          row.push(
            hasSignal(u) && u.lat != null && u.lon != null
              ? `${u.lat.toFixed(6)}, ${u.lon.toFixed(6)}`
              : ""
          );

          row.push(
            u.zones.length
              ? u.zones.map((z) => z.name).join(", ")
              : "Sin geocercas"
          );
        }
      });

      data.push(row);
    });

    // ================= XLSX =================
    const worksheet = XLSX.utils.aoa_to_sheet(data);
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, "Unidades");

    const fecha = new Date()
      .toISOString()
      .slice(0, 16)
      .replace("T", "_")
      .replace(":", "-");

    XLSX.writeFile(
      workbook,
      `unidades_geocercas_${fecha}.xlsx`
    );
  };


  /* ======================= RENDER ======================= */
  return (
    <div className="min-h-screen bg-white text-black p-6 mt-10">
      {/* ================= HEADER ================= */}
      <div className="mb-6 rounded-xl border border-gray-200 bg-gradient-to-r from-gray-50 to-white px-6 py-4 shadow-sm">
        <h1 className="text-2xl font-bold text-gray-900">
          Unidades y Geocercas
        </h1>
        <p className="text-sm text-gray-600 mt-1">
          Comparación horizontal • Operación diaria • Estilo Excel
        </p>
      </div>

      {/* ================= INPUT ================= */}
      <label className="block text-sm font-semibold text-gray-800 mb-1">
        Ingresa las unidades
      </label>

      <textarea
        className="w-full rounded-lg border border-gray-300 bg-white p-4 mb-2 text-black text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
        rows={3}
        value={unitInput}
        onChange={(e) => setUnitInput(e.target.value)}
        placeholder={`Ejemplo:\nITM 38578\nITM 38867`}
      />

      {/* ================= GRUPOS ================= */}
      {PREDEFINED_GROUPS.length > 0 && (
        <div className="mb-4 flex flex-wrap items-center gap-2 text-xs">
          <span className="text-gray-600 font-semibold">Grupos rápidos:</span>

          {PREDEFINED_GROUPS.map((g) => (
            <button
              key={g.id}
              type="button"
              onClick={() => setUnitInput(g.units.join("\n"))}
              className="rounded-full border border-gray-300 bg-white px-4 py-1.5 text-gray-800 hover:bg-gray-100 hover:border-gray-400 transition"
            >
              {g.name}
            </button>
          ))}
        </div>
      )}

      {/* ================= BOTONES ================= */}
      <div className="mb-6 flex gap-3">
        <button
          onClick={handleSearch}
          className="rounded-lg bg-blue-600 px-5 py-2.5 text-sm font-semibold text-white hover:bg-blue-700 disabled:opacity-60"
          disabled={loading}
        >
          {loading ? "Consultando..." : "Buscar unidades"}
        </button>

        {searches.length > 0 && (
          <>
            <button
              onClick={handleCopyTipo}
              className="rounded-lg bg-green-600 px-5 py-2.5 text-sm font-semibold text-white hover:bg-green-700"
            >
              Copiar columna Tipo (Excel)
            </button>
            <button
              onClick={handleDownloadExcel}
              className="rounded bg-emerald-600 px-4 py-2 text-white hover:bg-emerald-700"
            >
              Descargar Excel
            </button>
          </>


        )}
      </div>

      {/* ================= TABLA ================= */}
      {searches.length > 0 && (
        <div className="rounded-xl border border-gray-200 overflow-x-auto shadow-sm">
          <table className="min-w-max border-collapse text-sm">
            {/* ============ HEADER ============ */}
            <thead className="sticky top-0 z-40 bg-gray-100">
              <tr>
                {/* FIJAS */}
                <th className="sticky left-0 z-50 bg-gray-100 px-4 py-3 w-[170px] border-r font-semibold">
                  Unidad
                </th>
                <th className="sticky left-[170px] z-50 bg-gray-100 px-4 py-3 w-[200px] border-r font-semibold">
                  Ruta
                </th>
                <th className="sticky left-[370px] z-50 bg-gray-100 px-4 py-3 w-[230px] border-r font-semibold">
                  Segmento
                </th>

                {/* POR BÚSQUEDA */}
                {searches.map((s, idx) => (
                  <th
                    key={s.id}
                    colSpan={idx === 0 ? 5 : 2}
                    className="px-4 py-3 text-center border-r"
                  >
                    <div className="font-semibold">{s.label}</div>
                    <div className="text-[11px] text-gray-600">
                      {s.createdAt}
                    </div>
                  </th>
                ))}
              </tr>

              <tr>
                <th className="sticky left-0 z-50 bg-gray-100 border-r" />
                <th className="sticky left-[170px] z-50 bg-gray-100 border-r" />
                <th className="sticky left-[370px] z-50 bg-gray-100 border-r" />

                {searches.map((_, idx) => (
                  <React.Fragment key={idx}>
                    <th className="px-3 py-2">Tipo</th>
                    <th className="px-3 py-2">Hora</th>

                    {idx === 0 && (
                      <>
                        <th className="px-3 py-2">Última posición</th>
                        <th className="px-3 py-2">Lat / Lon</th>
                        <th className="px-3 py-2 border-r">Geocercas</th>
                      </>
                    )}
                  </React.Fragment>
                ))}
              </tr>
            </thead>

            {/* ============ BODY ============ */}
            <tbody>
              {searches[0].rows.map((_, rowIdx) => (
                <tr key={rowIdx} className="border-t hover:bg-gray-50">
                  {/* UNIDAD */}
                  <td className="sticky left-0 z-30 bg-white px-4 py-3 font-bold border-r shadow-[6px_0_12px_-8px_rgba(0,0,0,0.25)]">
                    {searches[0].rows[rowIdx].name}
                  </td>

                  {/* RUTA */}
                  <td className="sticky left-[170px] z-30 bg-white px-4 py-3 border-r shadow-[6px_0_12px_-8px_rgba(0,0,0,0.25)]">
                    <input
                      className="w-full rounded-lg border border-gray-300 bg-white px-3 py-2 text-black text-sm"
                      value={searches[0].rows[rowIdx].ruta}
                      onChange={(e) =>
                        updateRowField(
                          searches[0].id,
                          searches[0].rows[rowIdx].id,
                          "ruta",
                          e.target.value
                        )
                      }
                    />
                  </td>

                  {/* SEGMENTO */}
                  <td className="sticky left-[370px] z-30 bg-white px-4 py-3 border-r shadow-[6px_0_12px_-8px_rgba(0,0,0,0.25)]">
                    <input
                      className="w-full rounded-lg border border-gray-300 bg-white px-3 py-2 text-black text-sm"
                      value={searches[0].rows[rowIdx].segmento}
                      onChange={(e) =>
                        updateRowField(
                          searches[0].id,
                          searches[0].rows[rowIdx].id,
                          "segmento",
                          e.target.value
                        )
                      }
                    />
                  </td>

                  {/* POR BÚSQUEDA */}
                  {searches.map((s, searchIdx) => {
                    const baseUnit = searches[0].rows[rowIdx];

                    const u =
                      s.rows.find((r) => r.id === baseUnit.id) ??
                      {
                        ...baseUnit,
                        tipoManual: "",
                        horaTipo: "",
                        zones: [],
                        lat: undefined,
                        lon: undefined,
                        t: undefined,
                      };

                    return (
                      <React.Fragment key={`${s.id}-${u.id}`}>
                        <td className="px-3 py-2">
                          <input
                            className="w-12 rounded-lg border border-gray-300 bg-white text-black text-center font-semibold"
                            value={getTipo(u)}
                            title={getTipoTooltip(u)}
                            onChange={(e) =>
                              updateRowField(
                                s.id,
                                u.id,
                                "tipoManual",
                                e.target.value
                              )
                            }
                          />
                        </td>

                        <td className="px-3 py-2 text-sm">
                          {u.horaTipo ?? "—"}
                        </td>

                        {searchIdx === 0 && (
                          <>
                            <td className="px-3 py-2">{fmtDT(u.t)}</td>
                            <td className="px-3 py-2">
                              {hasSignal(u) && u.lat != null && u.lon != null
                                ? `${u.lat.toFixed(6)}, ${u.lon.toFixed(6)}`
                                : "—"}
                            </td>
                            <td className="px-3 py-2 border-r">
                              {u.zones.length ? (
                                <div className="flex flex-wrap gap-1">
                                  {u.zones.map((z) => (
                                    <Badge key={z.id} label={z.name} />
                                  ))}
                                </div>
                              ) : (
                                <span className="text-gray-500">
                                  Sin geocercas
                                </span>
                              )}
                            </td>
                          </>
                        )}
                      </React.Fragment>
                    );
                  })}
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}
    </div>
  );



}
